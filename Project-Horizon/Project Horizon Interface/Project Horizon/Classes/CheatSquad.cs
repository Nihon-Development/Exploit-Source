using System;
using System.Diagnostics;
using System.IO;
using System.IO.Pipes;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Windows.Forms;

namespace Project_Horizon.Classes
{
    class CheatSquad
    {
		public static string LuaPipeName = "taStqdau1Ch1ee33";
		private bool CheckForUpdates()
		{
			try
			{
				using (WebClient webClient = new WebClient())
				{
					if (!webClient.DownloadString("https://raw.githubusercontent.com/GianOfficial/CheatSquadAPI/master/Host").Contains("Updated https://github.com/GianOfficial/CheatSquadAPI/raw/master/csapi.dll"))
					{
						MessageBox.Show("Project Horizon Is Currently Unavailable Please Try Again Later", "Error: Not Updated", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
						return false;
					}
				}
			}
			catch (Exception)
			{
				MessageBox.Show("Can't Update Please Check Your Internet Connection", "Error: Wifi", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
			}
			return true;
		}

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool WaitNamedPipe(string name, int timeout);

		public static bool NamedPipeExist(string pipeName)
		{
			bool result;
			try
			{
				if (!CheatSquad.WaitNamedPipe("\\\\.\\pipe\\" + pipeName, 0))
				{
					int lastWin32Error = Marshal.GetLastWin32Error();
					if (lastWin32Error == 0)
					{
						return false;
					}
					if (lastWin32Error == 2)
					{
						return false;
					}
				}
				result = true;
			}
			catch (Exception)
			{
				result = false;
			}
			return result;
		}

		private static void LuaPipe(string ScriptToString)
		{
			if (CheatSquad.NamedPipeExist(CheatSquad.LuaPipeName))
			{
				new Thread(delegate ()
				{
					try
					{
						using (NamedPipeClientStream namedPipeClientStream = new NamedPipeClientStream(".", CheatSquad.EntryPointPipe, PipeDirection.Out))
						{
							namedPipeClientStream.Connect();
							using (StreamWriter streamWriter = new StreamWriter(namedPipeClientStream, Encoding.Default, 999999))
							{
								streamWriter.Write(ScriptToString);
								streamWriter.Dispose();
							}
							namedPipeClientStream.Dispose();
						}
					}
					catch (Exception)
					{
						MessageBox.Show("Failed To Connect To Pipe", "Error: Exception Handler", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					}
				}).Start();
			}
		}

		public void ExecuteScript(string csstring)
		{
			CheatSquad.LuaPipe(csstring);
		}

		public void LaunchExploit()
		{
			this.Inject();
		}
		private bool Inject()
		{
			if (CheatSquad.NamedPipeExist(CheatSquad.EntryPointPipe))
			{
				MessageBox.Show("Already Attached", "Error: Already Attached", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
			}
			else if (this.CheckForUpdates())
			{
				using (WebClient webClient = new WebClient())
				{
					if (File.Exists("HorizonSploit.dll"))
					{
						File.Delete("HorizonSploit.dll");
					}
					webClient.DownloadFile("https://github.com/GianOfficial/CheatSquadAPI/raw/master/csapi.dll", "HorizonSploit.dll");
					CheatSquad.APIInjector.Result result = CheatSquad.APIInjector.GetInstance.Inject("RobloxPlayerBeta", AppDomain.CurrentDomain.BaseDirectory + CheatSquad.EntryPointDLL);
					if (result != CheatSquad.APIInjector.Result.RobloxNotFound)
					{
						if (result == CheatSquad.APIInjector.Result.AttachFailed)
						{
							MessageBox.Show("Failed To Attach", "Error: Injection Failed", MessageBoxButtons.OK, MessageBoxIcon.Hand);
						}
					}
					else
					{
						MessageBox.Show("Roblox Client Not Found", "Error: Roblox Not Found", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					}
					CheatSquad.NamedPipeExist(CheatSquad.EntryPointPipe);
				}
				return File.Exists("HorizonSploit.dll");
			}
			return true;
		}

		public CheatSquad()
		{
		}

		static CheatSquad()
		{
		}

		private WebClient CSClientHost = new WebClient();

		public static string EntryPointPipe = "taStqdau1Ch1ee33";

		public static string EntryPointDLL = "HorizonSploit.dll";

		public sealed class APIInjector
		{
			[DllImport("kernel32.dll", SetLastError = true)]
			private static extern IntPtr OpenProcess(uint dwDesiredAccess, int bInheritHandle, uint dwProcessId);

			[DllImport("kernel32.dll")]
			public static extern IntPtr OpenProcessB(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);

			[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			public static extern IntPtr GetModuleHandle(string lpModuleName);

			[DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
			private static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

			[DllImport("kernel32.dll", ExactSpelling = true, SetLastError = true)]
			private static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, int dwSize, int flAllocationType, int flProtect);

			[DllImport("kernel32.dll", SetLastError = true)]
			private static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, IntPtr lpBuffer, int nSize, out UIntPtr lpNumberOfBytesWritten);

			[DllImport("kernel32.dll")]
			public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int dwSize, ref int lpNumberOfBytesRead);

			[DllImport("kernel32.dll")]
			private static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, int dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, int dwCreationFlags, out IntPtr lpThreadId);

			[DllImport("kernel32.dll")]
			private static extern IntPtr GetLastError();

			[DllImport("kernel32.dll", SetLastError = true)]
			private static extern int CloseHandle(IntPtr hObject);


			public static CheatSquad.APIInjector GetInstance
			{
				get
				{
					if (CheatSquad.APIInjector.Instance == null)
					{
						CheatSquad.APIInjector.Instance = new CheatSquad.APIInjector();
					}
					return CheatSquad.APIInjector.Instance;
				}
			}

			private APIInjector()
			{
			}

			public CheatSquad.APIInjector.Result Inject(string Roblox, string DLLEntryPointPath)
			{
				CheatSquad.APIInjector.Result result;
				if (!File.Exists(DLLEntryPointPath))
				{
					result = CheatSquad.APIInjector.Result.RobloxNotFound;
				}
				else
				{
					uint num = 0U;
					Process[] processes = Process.GetProcesses();
					for (int i = 0; i < processes.Length; i++)
					{
						if (processes[i].ProcessName == Roblox)
						{
							num = (uint)processes[i].Id;
							break;
						}
					}
					if (num == 0U)
					{
						result = CheatSquad.APIInjector.Result.RobloxNotFound;
					}
					else if (!this.LoadLibrary(num, DLLEntryPointPath))
					{
						result = CheatSquad.APIInjector.Result.AttachFailed;
					}
					else
					{
						result = CheatSquad.APIInjector.Result.Attached;
					}
				}
				return result;
			}

			public static bool LoadLibraryB(string procId, string dllPath)
			{
				if (!File.Exists(dllPath))
				{
					return false;
				}
				IntPtr intPtr = CheatSquad.APIInjector.OpenProcessB(1082, true, int.Parse(procId));
				if (intPtr == (IntPtr)null)
				{
					return false;
				}
				IntPtr procAddress = CheatSquad.APIInjector.GetProcAddress(CheatSquad.APIInjector.GetModuleHandle("Kernel32"), "LoadLibraryW");
				if (procAddress == (IntPtr)null)
				{
					return false;
				}
				IntPtr lpBuffer = Marshal.StringToHGlobalUni(dllPath);
				int byteCount = Encoding.Unicode.GetByteCount(dllPath);
				IntPtr intPtr2 = CheatSquad.APIInjector.VirtualAllocEx(intPtr, IntPtr.Zero, byteCount, 12288, 4);
				if (intPtr2 == (IntPtr)null)
				{
					return false;
				}
				UIntPtr value = (UIntPtr)null;
				IntPtr intPtr3;
				return CheatSquad.APIInjector.WriteProcessMemory(intPtr, intPtr2, lpBuffer, byteCount, out value) && !(value == (UIntPtr)null) && !(CheatSquad.APIInjector.CreateRemoteThread(intPtr, IntPtr.Zero, 0, procAddress, intPtr2, 0, out intPtr3) == IntPtr.Zero);
			}

			private bool LoadLibrary(uint RobloxProcess, string EntryPointDLLPath)
			{
				if (!File.Exists(EntryPointDLLPath))
				{
					return false;
				}
				IntPtr intPtr = CheatSquad.APIInjector.OpenProcess(1082U, 1, RobloxProcess);
				if (intPtr == (IntPtr)null)
				{
					return false;
				}
				IntPtr procAddress = CheatSquad.APIInjector.GetProcAddress(CheatSquad.APIInjector.GetModuleHandle("Kernel32"), "LoadLibraryW");
				if (procAddress == (IntPtr)null)
				{
					return false;
				}
				IntPtr lpBuffer = Marshal.StringToHGlobalUni(EntryPointDLLPath);
				int byteCount = Encoding.Unicode.GetByteCount(EntryPointDLLPath);
				IntPtr intPtr2 = CheatSquad.APIInjector.VirtualAllocEx(intPtr, IntPtr.Zero, byteCount, 12288, 4);
				if (intPtr2 == (IntPtr)null)
				{
					return false;
				}
				UIntPtr value = (UIntPtr)null;
				IntPtr intPtr3;
				return CheatSquad.APIInjector.WriteProcessMemory(intPtr, intPtr2, lpBuffer, byteCount, out value) && !(value == (UIntPtr)null) && !(CheatSquad.APIInjector.CreateRemoteThread(intPtr, IntPtr.Zero, 0, procAddress, intPtr2, 0, out intPtr3) == IntPtr.Zero);
			}


			static APIInjector()
			{
			}

			private static readonly IntPtr INTPTR_ZERO = (IntPtr)0;

			private const int PROCESS_CREATE_THREAD = 2;

			private const int PROCESS_QUERY_INFORMATION = 1024;

			private const int PROCESS_VM_OPERATION = 8;

			private const int PROCESS_VM_WRITE = 32;

			private const int PROCESS_VM_READ = 16;

			private const int MEM_COMMIT = 4096;

			private const int MEM_RESERVE = 8192;

			private const int PAGE_READWRITE = 4;

			private static CheatSquad.APIInjector Instance;

			public enum Result
			{
				RobloxNotFound,
				AttachFailed,
				Attached
			}
		}
	}
}
